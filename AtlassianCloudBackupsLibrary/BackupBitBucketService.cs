namespace AtlassianCloudBackupsLibrary
{
    using System;
    using System.Threading.Tasks;
    using Microsoft.Extensions.Configuration;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Text;
    using Helpers;
    using LibGit2Sharp;
    using Newtonsoft.Json.Linq;

    public class BackupBitBucketService : IBackupJob
    {
        //private const string BitbucketUserUrl = "https://api.bitbucket.org/2.0/users/{0}";
        //private const string BitbucketTeamUrl = "https://api.bitbucket.org/2.0/teams/{0}";
        
        private const string BitbucketAccountReposUrl = "https://api.bitbucket.org/2.0/repositories/{0}";

        /// <summary>
        /// Log label this task will use for entries into the common log file generated by this tool
        /// </summary>
        private readonly string _logLabel = "Bitbucket-Backup-Service";

        /// <summary>
        /// HttpClient instance
        /// 
        /// Configured fully in the Client property
        /// </summary>
        private HttpClient _client;

        /// <summary>
        /// Cookie jar instance for the HttpClient
        /// 
        /// Used to store cookies from HTTP requests and pass them along on subsequent requests
        /// </summary>
        private CookieContainer _cookieJar;

        /// <summary>
        /// HttpClient instance property
        /// </summary>
        private HttpClient Client
        {
            get
            {
                if (_client == null)
                {
                    if (_cookieJar == null)
                    {
                        _cookieJar = new CookieContainer();
                    }

                    // Enable the client to use cookies
                    _client = new HttpClient(new HttpClientHandler
                    {
                        CookieContainer = _cookieJar,
                        UseCookies = true,
                        UseDefaultCredentials = false
                    });
                }
                return _client;
            }
        }

        private readonly IConfigurationSection _config;
        private List<BitBucketRepository> _repositories;

        public bool TeamAccountBackupEnabled => bool.Parse(_config["useTeam"]);
        public Func<IConfigurationSection, Task> PrepareFunction { get; set; }
        public Func<IConfigurationSection, Task> CleanUpFunction { get; set; }

        public BackupBitBucketService(IConfigurationSection config)
        {
            _config = config;
            _repositories = new List<BitBucketRepository>();
        }

        public async Task<IBackupJob> Execute()
        {
            Logger.Current.Log(_logLabel, "Starting BitBucket backup task...");

            var backupTeamAccount = bool.Parse(_config["useTeam"]);
            if (backupTeamAccount)
            {
                Logger.Current.Log(_logLabel, "Backing up team account based on configuration...");
            }

            Logger.Current.Log(_logLabel, string.Format("Beginning backup for Bitbucket account {0}...", (TeamAccountBackupEnabled) ? _config["teamName"] : _config["userName"]));

            using (Client)
            {
                Client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", Convert.ToBase64String(
                    Encoding.ASCII.GetBytes(string.Format("{0}:{1}", _config["user"], _config["password"]))));

                await GetRepositoriesForAccount();

                Logger.Current.Log(_logLabel, string.Format("{0} repos found for account...", _repositories.Count));

                foreach (var repo in _repositories)
                {
                    var repoDestination = Path.Combine(_config["destination"], repo.Name);
                    
                    // We need to fetch updates if the directory already exists
                    if (Directory.Exists(repoDestination) && Repository.IsValid(repoDestination))
                    {
                        FetchUpdatesForRepo(repo, repoDestination);
                    }
                    // Create a bare clone of the repository
                    else
                    {
                        CloneBareRepo(repo, repoDestination);
                    }

                    Logger.Current.Log(_logLabel, "Clone operation complete.");
                }
            }

            Logger.Current.Log(_logLabel, "Backup complete.");
            return this;
        }

        public async Task<IBackupJob> Prepare()
        {
            if (PrepareFunction != null)
            {
                await PrepareFunction(_config);
            }
            return this;
        }

        public async Task<IBackupJob> CleanUp()
        {
            if (CleanUpFunction != null)
            {
                await CleanUpFunction(_config);
            }
            return this;
        }

        /// <summary>
        /// Builds the list of repositories for the selected team or user account. 
        /// 
        /// May be called recursively if multiple pages of results exist
        /// </summary>
        /// <param name="url">URL of next page of results</param>
        /// <returns></returns>
        private async Task GetRepositoriesForAccount(string url = null)
        {
            var baseUrl = string.Format(BitbucketAccountReposUrl, (TeamAccountBackupEnabled) ? _config["teamName"] : _config["userName"]);

            var apiUrl = (string.IsNullOrWhiteSpace(url)) ? baseUrl : url;

            var response = await Client.GetAsync(apiUrl);
            var jsonString = await response.Content.ReadAsStringAsync();
            dynamic json = JObject.Parse(jsonString);

            foreach (var repo in json.values)
            {
                _repositories.Add(BitBucketRepository.Create(repo));
            }

            int numPages = json.size / json.pagelen;
            int currentPage = int.Parse((string)json.page);
            int nextPage = (currentPage < numPages) ? currentPage + 1 : 0;

            if (nextPage != 0 && nextPage <= numPages)
            {
                await GetRepositoriesForAccount(string.Join("?", baseUrl, "page=" + nextPage));
            }
        }

        private void FetchUpdatesForRepo(BitBucketRepository repo, string repoDestination)
        {
            Logger.Current.Log(_logLabel, string.Format("Updating {0} repo from remotes...", repo.Name));

            var logMessage = string.Empty;
            using (var existingRepo = new Repository(repoDestination))
            {
                var options = new FetchOptions();
                options.CredentialsProvider = (url, usernameFromUrl, types) =>
                    new UsernamePasswordCredentials()
                    {
                        Username = _config["user"],
                        Password = _config["password"]
                    };

                foreach (Remote remote in existingRepo.Network.Remotes)
                {
                    IEnumerable<string> refSpecs = remote.FetchRefSpecs.Select(x => x.Specification);
                    Commands.Fetch(existingRepo, remote.Name, refSpecs, options, logMessage);
                }
            }

            if (!string.IsNullOrWhiteSpace(logMessage))
            {
                Logger.Current.Log(_logLabel, logMessage);
            }

            Logger.Current.Log(_logLabel, string.Format("Fetch complete for {0} repo.", repo.Name));
        }

        private void CloneBareRepo(BitBucketRepository repo, string repoDestination)
        {
            // Already exists or not empty
            if (Directory.Exists(repoDestination) && Directory.EnumerateFileSystemEntries(repoDestination).Any())
            {
                Logger.Current.Log(_logLabel, string.Format("Unable to clone {0} repo to an existing or non-empty directory.  Aborting operation.", repo.Name));
                return;
            }

            Logger.Current.Log(_logLabel, string.Format("Creating bare clone of repo {0} at {1}", repo.Name, repoDestination));

            var cloneOpts = new CloneOptions
            {
                CredentialsProvider =
                    (url, user, cred) => new UsernamePasswordCredentials
                    {
                        Username = _config["user"],
                        Password = _config["password"]
                    },
                IsBare = true
            };

            Repository.Clone(repo.CloneUrl, repoDestination, cloneOpts);
        }
    }
}
